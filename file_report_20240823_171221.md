# Project Files Overview

### `README.md`

```
# Advanced AI Video Processor

## Overview
Advanced AI Video Processor is a web application built using Flask, OpenCV, and PyTorch. It provides users with the ability to upload videos, resize them, and perform advanced AI-based frame interpolation to increase FPS (frames per second). The application is designed to be extensible and can be used as a foundation for more complex video processing tasks.

## Key Features
- **Secure Video Upload**: Allows users to upload videos in common formats (MP4, AVI, MOV) securely.
- **Video Resizing**: Uses OpenCV to resize videos while maintaining aspect ratio.
- **AI-Based Frame Interpolation**: Implements AI models like RIFE (Real-Time Intermediate Flow Estimation) for smooth frame interpolation, increasing the FPS of a video.
- **H.265 Encoding**: Uses FFmpeg for efficient video encoding.

## Project Structure
```
advanced-ai-video-processor/
├── .gitignore              # Ignore files for Git
├── app/
│   └── main.py             # Main Flask application code
├── LICENSE                 # License file
├── README.md               # Project documentation
├── requirements.txt        # Python dependencies
├── static/
│   └── uploads/            # Directory to store uploaded files
└── templates/
    └── index.html          # HTML template for the upload page
```

## Folder and File Descriptions
- `app/main.py`: The core of the Flask application. It handles routing, video processing logic, and integrates the AI model.
- `static/uploads/`: Directory where uploaded videos are temporarily stored.
- `templates/index.html`: The HTML template that serves the video upload form.
- `requirements.txt`: Contains the list of Python dependencies required to run the project.

## Setup Instructions
### Prerequisites
- Python 3.9+
- pip (Python package manager)
- Virtual environment tool (e.g., venv, virtualenv, or conda)
- Git (for cloning the repository)
- FFmpeg (Ensure FFmpeg is installed and added to your system's PATH)

### Installation
1. Clone the Repository:
   ```bash
   git clone https://github.com/geek2geeks/advanced-ai-video-processor.git
   cd advanced-ai-video-processor
   ```
2. Set Up a Virtual Environment:
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # On Windows use: .\venv\Scripts\activate
   ```
3. Install Required Dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Install FFmpeg:
   - Download and install FFmpeg from [here](https://ffmpeg.org/download.html).
   - Ensure FFmpeg is added to your system's PATH.

## Running the Application
1. Set the Flask Application Environment Variable:
   ```bash
   set FLASK_APP=app.main  # For Windows
   export FLASK_APP=app.main  # For Unix/Mac
   ```
2. Run the Flask Application:
   ```bash
   flask run
   ```
3. Access the Application:
   - Open your browser and go to `http://127.0.0.1:5000/`.
   - You should see the upload page where you can select a video file to upload and process.

## Usage
### Uploading a Video
1. On the main page, use the "Choose File" button to select a video file from your local machine.
2. Click the "Upload" button to upload the video to the server.
3. The server will process the video based on the options provided (e.g., resizing or frame interpolation).

### Video Resizing
1. Once the video is uploaded, you can choose the desired resolution or aspect ratio for resizing.
2. The server processes the video using OpenCV, preserving the aspect ratio during resizing.

### AI Frame Interpolation
1. Specify the target FPS you want to achieve.
2. The server will use the pre-trained RIFE model to interpolate frames and increase the video FPS.

### Video Encoding
After processing, the video is encoded using H.265 (HEVC) for efficient storage and playback.

## Testing
### Running Unit Tests
Unit tests are included to verify the functionality of the video processing features.

Run the tests using pytest:
```bash
pytest tests/
```
Ensure all tests pass before deploying or sharing the application.

## Troubleshooting
### Common Issues
#### TemplateNotFound Error
- Ensure that the `templates/` directory is correctly located relative to the application.
- Verify that the environment variables and paths are correctly set.

#### FFmpeg Not Found
- Ensure FFmpeg is installed and added to your system's PATH.
- Restart your terminal or command prompt after installing FFmpeg.

### Logging
The application includes basic logging to help debug issues. Logs can be found in the terminal where the application is running.

## Contributing
### How to Contribute
1. Fork the repository on GitHub.
2. Clone your forked repository to your local machine:
   ```bash
   git clone https://github.com/yourusername/advanced-ai-video-processor.git
   ```
3. Create a new branch for your feature or bug fix:
   ```bash
   git checkout -b feature/your-feature-name
   ```
4. Make your changes and commit them with a descriptive message:
   ```bash
   git commit -m "Description of your changes"
   ```
5. Push your changes to your forked repository:
   ```bash
   git push origin feature/your-feature-name
   ```
6. Create a Pull Request on the original repository and describe the changes you've made.

### Code of Conduct
Please adhere to the project's code of conduct in all interactions.

## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements
- [Flask](https://flask.palletsprojects.com/): A lightweight WSGI web application framework in Python.
- [OpenCV](https://opencv.org/): A library of programming functions mainly aimed at real-time computer vision.
- [PyTorch](https://pytorch.org/): An open-source machine learning library based on the Torch library, used for applications such as computer vision and natural language processing.

## Future Work
- **User Authentication**: Implement user authentication and session management.
- **Video Persistence**: Add functionality to save processed videos between sessions.
- **Additional AI Models**: Integrate other AI models for video processing, such as super-resolution or video stabilization.
```

### `generate_file_report.py`

```
import os
import datetime

# Define the root directory of the project
project_root = '.'

# Files and directories to exclude
exclude_files = {'LICENSE', '.gitignore'}
exclude_dirs = {'__pycache__', '.git', 'venv', 'env'}
exclude_extensions = {'.pyc', '.pyo', '.pyd', '.db', '.sqlite3'}

# Function to write file content to markdown
def write_file_content(md_file, file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        md_file.write(f"### `{file_path}`\n\n")
        md_file.write("```\n")
        md_file.write(content)
        md_file.write("\n```\n\n")
    except UnicodeDecodeError:
        md_file.write(f"### `{file_path}`\n\n")
        md_file.write("> **Warning:** Unable to read file due to encoding issues.\n\n")
    except Exception as e:
        md_file.write(f"### `{file_path}`\n\n")
        md_file.write(f"> **Error:** {str(e)}\n\n")

# Function to check if a file should be excluded
def should_exclude_file(file_name):
    return (file_name in exclude_files or
            file_name.startswith('file_report_') or
            os.path.splitext(file_name)[1] in exclude_extensions)

# Function to generate file tree
def generate_file_tree(start_path):
    tree = []
    for root, dirs, files in os.walk(start_path):
        level = root.replace(start_path, '').count(os.sep)
        indent = '│   ' * (level - 1) + '├── '
        tree.append(f"{indent}{os.path.basename(root)}/")
        for file in files:
            if not should_exclude_file(file):
                tree.append('│   ' * level + '├── ' + file)
    return '\n'.join(tree)

# Function to generate the markdown file
def generate_markdown():
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    output_md_path = f'file_report_{timestamp}.md'
    
    with open(output_md_path, 'w', encoding='utf-8') as md_file:
        md_file.write("# Project Files Overview\n\n")
        
        for root, dirs, files in os.walk(project_root):
            dirs[:] = [d for d in dirs if d not in exclude_dirs]
            files = sorted([f for f in files if not should_exclude_file(f)])

            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, project_root)
                write_file_content(md_file, relative_path)

        # Add file tree at the end
        md_file.write("## Project File Structure\n\n")
        md_file.write("```\n")
        md_file.write(generate_file_tree(project_root))
        md_file.write("\n```\n")

    print(f"Markdown file generated at: {output_md_path}")

# Execute the script
if __name__ == '__main__':
    generate_markdown()
```

### `app\main.py`

```
from flask import Flask, render_template, request, redirect, url_for, flash
from werkzeug.utils import secure_filename
import os
from app.video_processing import resize_video
import cv2  # Make sure to import cv2 for the interpolation constant

app = Flask(__name__, template_folder='../templates')

# Debugging: Print the current working directory and template folder
print("Current working directory:", os.getcwd())
print("Template folder:", app.template_folder)

UPLOAD_FOLDER = 'static/uploads'
ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.secret_key = 'your_secret_key'  # Required to use flash messages

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_video():
    if 'file' not in request.files:
        flash('No file part')
        return redirect(request.url)
    file = request.files['file']
    if file.filename == '':
        flash('No selected file')
        return redirect(request.url)
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(input_path)
        return f'File {filename} uploaded successfully'
    return redirect(request.url)

@app.route('/resize', methods=['POST'])
def resize_video_route():
    if 'file' not in request.files:
        flash('No file part')
        return redirect(request.url)
    file = request.files['file']
    if file.filename == '':
        flash('No selected file')
        return redirect(request.url)
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        input_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(input_path)
        
        # Get resize parameters from the form
        width = request.form.get('width')
        height = request.form.get('height')
        interpolation = int(request.form.get('interpolation', cv2.INTER_LINEAR))
        
        # Convert width and height to integers if provided
        width = int(width) if width else None
        height = int(height) if height else None

        # Define the output path
        output_filename = 'resized_' + filename
        output_path = os.path.join(app.config['UPLOAD_FOLDER'], output_filename)

        # Perform the resizing
        resize_video(input_path, output_path, width=width, height=height, interpolation=interpolation)

        return f'Video resized and saved as {output_path}'
    return redirect(request.url)

if __name__ == '__main__':
    app.run(debug=True)

```

### `app\video_processing.py`

```
import cv2

def resize_video(input_path, output_path, width=None, height=None, interpolation=cv2.INTER_LINEAR):
    """
    Resize a video while maintaining its aspect ratio.

    :param input_path: Path to the input video file.
    :param output_path: Path to save the resized video.
    :param width: Desired width of the resized video. If None, height will be used to calculate width.
    :param height: Desired height of the resized video. If None, width will be used to calculate height.
    :param interpolation: Interpolation method used for resizing.
    """
    cap = cv2.VideoCapture(input_path)
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # or 'XVID' for .avi
    
    if not cap.isOpened():
        raise ValueError("Could not open the video file.")

    # Get original dimensions
    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    # Calculate new dimensions
    if width and not height:
        aspect_ratio = original_height / original_width
        height = int(width * aspect_ratio)
    elif height and not width:
        aspect_ratio = original_width / original_height
        width = int(height * aspect_ratio)
    elif not width and not height:
        width, height = original_width, original_height

    # Set up the video writer
    out = cv2.VideoWriter(output_path, fourcc, cap.get(cv2.CAP_PROP_FPS), (width, height))

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        resized_frame = cv2.resize(frame, (width, height), interpolation=interpolation)
        out.write(resized_frame)

    cap.release()
    out.release()

```

### `templates\index.html`

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Upload and Resizing</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        input[type="file"],
        input[type="number"],
        select {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Upload and Resize Your Video</h1>
        <form action="/resize" method="POST" enctype="multipart/form-data">
            <label for="file">Select video file:</label>
            <input type="file" name="file" accept="video/*"><br>

            <label for="width">Width (optional):</label>
            <input type="number" name="width" placeholder="Width"><br>

            <label for="height">Height (optional):</label>
            <input type="number" name="height" placeholder="Height"><br>

            <label for="interpolation">Interpolation method:</label>
            <select name="interpolation">
                <option value="0">Nearest (cv2.INTER_NEAREST)</option>
                <option value="1">Linear (cv2.INTER_LINEAR)</option>
                <option value="2">Cubic (cv2.INTER_CUBIC)</option>
            </select><br>

            <button type="submit">Resize Video</button>
        </form>
    </div>
</body>
</html>

```

## Project File Structure

```
├── ./
├── generate_file_report.py
├── README.md
├── .git/
│   ├── COMMIT_EDITMSG
│   ├── config
│   ├── description
│   ├── FETCH_HEAD
│   ├── HEAD
│   ├── index
│   ├── packed-refs
│   ├── hooks/
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   ├── update.sample
│   ├── info/
│   │   ├── exclude
│   ├── logs/
│   │   ├── HEAD
│   │   ├── refs/
│   │   │   ├── heads/
│   │   │   │   ├── main
│   │   │   ├── remotes/
│   │   │   │   ├── origin/
│   │   │   │   │   ├── HEAD
│   │   │   │   │   ├── main
│   ├── objects/
│   │   ├── 0e/
│   │   │   ├── 9e3dd68a75999b553db59d863e9df9a4a672a9
│   │   ├── 26/
│   │   │   ├── 02a0207cba0604b4f6bf0d8a45bb51308f4f47
│   │   │   ├── 512422d59d53f21fe21e9f8b06f81e72593c62
│   │   ├── 41/
│   │   │   ├── 7b67ac584c6c6ecf23eae3c50ddd43da8bac63
│   │   ├── 43/
│   │   │   ├── 2d46c9933ac4926cedeaf89263892785066e8c
│   │   ├── 45/
│   │   │   ├── 4a5fa4236472bf950630202b4dfba46bcab428
│   │   ├── 66/
│   │   │   ├── b8213283e268a55d0830bf2a4bf440fbe8b2f4
│   │   ├── 67/
│   │   │   ├── 47467586c9e3d9c8c64ded5cad21e62ea6fbd0
│   │   ├── 68/
│   │   │   ├── 36f6b1538ff3bd91ad4318b04d5038a2884b01
│   │   ├── 7c/
│   │   │   ├── 68c7eafa64cb5fb42549df2513d50a9a99a49a
│   │   ├── 89/
│   │   │   ├── 608f0234026931f3e3c254078548a56b99bf6a
│   │   ├── 97/
│   │   │   ├── aa85972987893ac7d777f4a297ccd32d8ad20d
│   │   ├── 9c/
│   │   │   ├── 5c695714971160a27e63902f9dc7896cccc7b2
│   │   ├── e4/
│   │   │   ├── b583ecb56d24a6cbe5c726836f44a27ef0b9f1
│   │   ├── ee/
│   │   │   ├── 27ee166ad5b76c8b5ac96a7841ee2d8bb86150
│   │   ├── f8/
│   │   │   ├── 41e4ce014cd24d63c61fbf9cf1b0a667f4ff52
│   │   │   ├── e5898227a2e3d36089472d45eed25004a938c3
│   │   ├── info/
│   │   ├── pack/
│   │   │   ├── pack-65ab8f09dbd2287525bb6a43e4a98a36e77bdcab.idx
│   │   │   ├── pack-65ab8f09dbd2287525bb6a43e4a98a36e77bdcab.pack
│   │   │   ├── pack-65ab8f09dbd2287525bb6a43e4a98a36e77bdcab.rev
│   ├── refs/
│   │   ├── heads/
│   │   │   ├── main
│   │   ├── remotes/
│   │   │   ├── origin/
│   │   │   │   ├── HEAD
│   │   │   │   ├── main
│   │   ├── tags/
├── app/
│   ├── main.py
│   ├── video_processing.py
│   ├── __pycache__/
├── static/
│   ├── uploads/
├── templates/
│   ├── index.html
```
